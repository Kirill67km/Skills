# Jenkins

**Jenkins** — система автоматизации разработки программного обеспечения с открытым исходным кодом на Java. 
Позволяет автоматизировать часть процесса разработки, в которой не обязательно участие человека, что обеспечивает непрерывную интеграцию.

Jenkins поддерживает работу с сотнями инструментов и сервисов с помощью более тысячи различных плагинов. 
Среди поддерживаемых инструментов есть системы контроля версий, такие как Subversion, Git, Mercurial

**Официальная документация** - `https://www.jenkins.io/doc/`

**Сайт с подробным описанием работы** - `https://www.andreyolegovich.ru/dvps/jenkins/basics/`

*По умолчанию слушает порт*  `TCP/8080`

## **Установка (Яндекс.Облако, Docker, K8S, Linux, MacOS):**
1. При создании виртуальной машины в Yandex.Cloud в Cloud Marketplace выбрать Jenkins
2. После завершения установки обновить пакеты
3. Проверить статус работы сервиса Jenkins
4. Запустить сервис
5. Перейти по публичну ipv4 в браузере
6. Пароль находится по адресу  `/var/lib/jenkins/secrets/initialAdminPassword ` (должны быть привелегии sudo)
7. Выбираем необходимые плагины
8. Регистрируем пользователя

## **Что такое Jenkins Pipeline?**

**Jenkins Pipeline** — набор плагинов, позволяющий определить жизненный цикл сборки и доставки приложения как код. 
Он представляет собой Groovy-скрипт с использованием Jenkins Pipeline DSL и хранится стандартно в системе контроля версий

Существует два способа описания пайплайнов — **скриптовый** и **декларативный.**
```
 1. Scripted: 

node {
  stage('Example') {
      try {
          sh 'exit 1'
      }
      catch (exc) {
          throw exc
      }
  }
}
```

```
 2. Declarative 

pipeline {
  agent any
  stages {
      stage("Stage name") {
          steps {}
      }
  }
}
```

Они оба имеют структуру, но в скриптовом она вольная — достаточно указать, на каком слейве запускаться (node), и стадию сборки (stage), а также написать Groovy-код для запуска атомарных степов.
Декларативный пайплайн определен более жестко, и, соответственно, его структура читается лучше.

Рассмотрим подробнее декларативный пайплайн.

В структуре должна быть определена директива  `pipeline. `

Также нужно определить, на каком агенте (agent) будет запущена сборка.

Дальше идет определение  `stages `, которые будут содержаться в пайплайне, и обязательно должен быть конкретный стейдж с названием stage(“name”). Если имени нет, тест упадет в runtime с ошибкой  `«Добавьте имя стейджа» `.

Обязательно должна быть директива  `steps `, в которой уже содержатся атомарные шаги сборки. Например, вы можете вывести в консоль «Hello».

```
pipeline { // определение декларативного pipeline
  agent any // определяет, на каком агенте будет запущена сборка
 
  stages { // содержит стейджи сборки
      stage("Stage name") { // отдельный стейдж сборки
          steps { // набор шагов в рамках стейджа
              echo "Hello work" // один из шагов сборки
          }
      }
  }
}
```

```
pipeline {
  stages {
      stage("Post stage") {
          post { // определяет действия по завершении стейджа
              success { // триггером исполнения секции является состояние сборки 
                  archiveArtifacts artifacts: '**/target/*'
              }
          }
      }
  }
```

```
post { // после всей сборки
      cleanup {
          cleanWs()
      }
  }
}
```

Если сборка и стейдж завершились успешно, можно сохранить артефакты или почистить workspace после сборки.
Если же при таких условиях использовался бы скриптовый пайплайн, пришлось бы за этим «флоу» следить самостоятельно, добавляя обработку исключений, условия и т.д.



